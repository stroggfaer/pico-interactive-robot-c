# AI ÐŸÑ€Ð¾Ð¼Ð¿Ñ‚: Ð”Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð½Ð¾Ð²Ñ‹Ñ… Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹

## ðŸš€ Ð Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð¸Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾ÑÑ‚Ð¸ Robot Pico

Ð’Ñ‹ Ð¿Ð¾Ð¼Ð¾Ð³Ð°ÐµÑ‚Ðµ Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð½Ð¾Ð²ÑƒÑŽ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ Ð² embedded Ð¿Ñ€Ð¾ÐµÐºÑ‚ Robot Pico. Ð¡Ð»ÐµÐ´ÑƒÐ¹Ñ‚Ðµ Ð¿Ñ€Ð¸Ð½Ñ†Ð¸Ð¿Ð°Ð¼ Ð¼Ð¾Ð´ÑƒÐ»ÑŒÐ½Ð¾Ð¹ Ñ€Ð°Ð·Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ Ð¸ embedded Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¸ÑÐ¼.

### ðŸ“‹ ÐÐ»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹

#### 1. ÐÐ½Ð°Ð»Ð¸Ð· Ñ‚Ñ€ÐµÐ±Ð¾Ð²Ð°Ð½Ð¸Ð¹
- âœ… Ð¡Ð¾Ð²Ð¼ÐµÑÑ‚Ð¸Ð¼Ð¾ÑÑ‚ÑŒ Ñ RP2040 (264KB RAM, 2MB Flash)
- âœ… Ð¡Ð¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²Ð¸Ðµ Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾Ð¼Ñƒ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸ (1ms Ñ†Ð¸ÐºÐ»)
- âœ… ÐœÐ¸Ð½Ð¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ðµ Ð²Ð»Ð¸ÑÐ½Ð¸Ðµ Ð½Ð° ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ð¹ ÐºÐ¾Ð´
- âœ… Ð’Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ÑÑ‚ÑŒ Ð¾Ñ‚ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ñ Ð´Ð»Ñ ÑÐºÐ¾Ð½Ð¾Ð¼Ð¸Ð¸ Ñ€ÐµÑÑƒÑ€ÑÐ¾Ð²

#### 2. ÐŸÐ»Ð°Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð°Ñ€Ñ…Ð¸Ñ‚ÐµÐºÑ‚ÑƒÑ€Ñ‹
- âœ… ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚ÑŒ Ð¼Ð¾Ð´ÑƒÐ»ÑŒ (core/display/emotions/Ð½Ð¾Ð²Ñ‹Ð¹)
- âœ… Ð¡Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ API Ð¸Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹Ñ
- âœ… Ð’Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼Ñ‹Ðµ Ð¿Ð¸Ð½Ñ‹ GPIO
- âœ… ÐžÑ†ÐµÐ½Ð¸Ñ‚ÑŒ Ð²Ð»Ð¸ÑÐ½Ð¸Ðµ Ð½Ð° Ð¿Ñ€Ð¾Ð¸Ð·Ð²Ð¾Ð´Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ

#### 3. ÐŸÐ¾ÑÑ‚Ð°Ð¿Ð½Ð°Ñ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ
- âœ… Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ Ð¼Ð¸Ð½Ð¸Ð¼Ð°Ð»ÑŒÐ½ÑƒÑŽ Ð²ÐµÑ€ÑÐ¸ÑŽ (MVP)
- âœ… Ð˜Ð½Ñ‚ÐµÐ³Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ñ Ð¾ÑÐ½Ð¾Ð²Ð½Ñ‹Ð¼ Ñ†Ð¸ÐºÐ»Ð¾Ð¼
- âœ… Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ ÐºÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸ÑŽ Ð¸ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸
- âœ… Ð ÐµÐ°Ð»Ð¸Ð·Ð¾Ð²Ð°Ñ‚ÑŒ Ð¿Ð¾Ð»Ð½Ñ‹Ð¹ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¾Ð½Ð°Ð»

### ðŸŽµ ÐŸÑ€Ð¸Ð¼ÐµÑ€: Ð”Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð·Ð²ÑƒÐºÐ° (Buzzer)

#### Ð­Ñ‚Ð°Ð¿ 1: Ð—Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ñ‡Ð½Ñ‹Ð¹ Ñ„Ð°Ð¹Ð»
```cpp
// include/audio/buzzer.h
#ifndef BUZZER_H
#define BUZZER_H

#include "pico/stdlib.h"
#include "hardware/pwm.h"

// ÐšÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ñ
#define BUZZER_PIN 15
#define BUZZER_PWM_SLICE pwm_gpio_to_slice_num(BUZZER_PIN)

// ÐÐ¾Ñ‚Ñ‹ (Ñ‡Ð°ÑÑ‚Ð¾Ñ‚Ñ‹ Ð² Hz)
typedef enum {
    NOTE_SILENT = 0,
    NOTE_C4 = 262,
    NOTE_D4 = 294,
    NOTE_E4 = 330,
    NOTE_F4 = 349,
    NOTE_G4 = 392,
    NOTE_A4 = 440,
    NOTE_B4 = 494
} buzzer_note_t;

// Ð¡Ñ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð° ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ñ
typedef struct {
    bool enabled;
    bool playing;
    uint32_t start_time;
    uint32_t duration_ms;
    buzzer_note_t current_note;
} buzzer_state_t;

// API Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸
void buzzer_init(void);
void buzzer_play_note(buzzer_note_t note, uint32_t duration_ms);
void buzzer_play_melody(const buzzer_note_t* notes, const uint32_t* durations, int count);
void buzzer_stop(void);
void buzzer_update(void);  // Ð’Ñ‹Ð·Ñ‹Ð²Ð°ÐµÑ‚ÑÑ Ð² main loop
bool buzzer_is_playing(void);

// ÐŸÑ€ÐµÐ´ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ñ‹Ðµ Ð¼ÐµÐ»Ð¾Ð´Ð¸Ð¸
void buzzer_play_startup_sound(void);
void buzzer_play_notification(void);
void buzzer_play_error(void);

#endif // BUZZER_H
```

#### Ð­Ñ‚Ð°Ð¿ 2: Ð ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ
```cpp
// src/audio/buzzer.c
#include "buzzer.h"

static buzzer_state_t buzzer_state = {0};
static uint slice_num;

void buzzer_init(void) {
    gpio_set_function(BUZZER_PIN, GPIO_FUNC_PWM);
    slice_num = pwm_gpio_to_slice_num(BUZZER_PIN);
    
    // ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ° PWM
    pwm_config config = pwm_get_default_config();
    pwm_config_set_clkdiv(&config, 8.f);  // Ð”ÐµÐ»Ð¸Ñ‚ÐµÐ»ÑŒ Ñ‡Ð°ÑÑ‚Ð¾Ñ‚Ñ‹
    pwm_init(slice_num, &config, true);
    
    buzzer_state.enabled = true;
    buzzer_stop();
    
    printf("[BUZZER] Initialized on pin %d\n", BUZZER_PIN);
}

void buzzer_play_note(buzzer_note_t note, uint32_t duration_ms) {
    if (!buzzer_state.enabled) return;
    
    buzzer_state.current_note = note;
    buzzer_state.duration_ms = duration_ms;
    buzzer_state.start_time = to_ms_since_boot(get_absolute_time());
    buzzer_state.playing = true;
    
    if (note == NOTE_SILENT) {
        pwm_set_gpio_level(BUZZER_PIN, 0);
    } else {
        // Ð£ÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ° Ñ‡Ð°ÑÑ‚Ð¾Ñ‚Ñ‹ PWM Ð´Ð»Ñ Ð½Ð¾Ñ‚Ñ‹
        uint32_t clock_freq = 125000000;  // 125 MHz
        uint32_t divider = 8;
        uint32_t pwm_freq = clock_freq / divider;
        uint16_t wrap = pwm_freq / note - 1;
        
        pwm_set_wrap(slice_num, wrap);
        pwm_set_gpio_level(BUZZER_PIN, wrap / 2);  // 50% duty cycle
    }
}

void buzzer_update(void) {
    if (!buzzer_state.playing) return;
    
    uint32_t current_time = to_ms_since_boot(get_absolute_time());
    if (current_time - buzzer_state.start_time >= buzzer_state.duration_ms) {
        buzzer_stop();
    }
}

void buzzer_stop(void) {
    pwm_set_gpio_level(BUZZER_PIN, 0);
    buzzer_state.playing = false;
    buzzer_state.current_note = NOTE_SILENT;
}

// ÐŸÑ€ÐµÐ´ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ñ‹Ðµ Ð¼ÐµÐ»Ð¾Ð´Ð¸Ð¸
void buzzer_play_startup_sound(void) {
    static const buzzer_note_t notes[] = {NOTE_C4, NOTE_E4, NOTE_G4};
    static const uint32_t durations[] = {200, 200, 400};
    buzzer_play_melody(notes, durations, 3);
}
```

#### Ð­Ñ‚Ð°Ð¿ 3: Ð˜Ð½Ñ‚ÐµÐ³Ñ€Ð°Ñ†Ð¸Ñ Ð² main.cpp
```cpp
// Ð’ main.cpp Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ:

#include "buzzer.h"  // ÐÐ¾Ð²Ñ‹Ð¹ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº

// Ð’ main() Ð¿Ð¾ÑÐ»Ðµ Ð¸Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸ Ð´Ð¸ÑÐ¿Ð»ÐµÑ:
buzzer_init();
buzzer_play_startup_sound();

// Ð’ Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ð¼ Ñ†Ð¸ÐºÐ»Ðµ:
while (true) {
    // ... ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ð¹ ÐºÐ¾Ð´ ...
    
    buzzer_update();  // ÐžÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð·Ð²ÑƒÐºÐ°
    
    sleep_ms(1);  // 1ms Ñ†Ð¸ÐºÐ»
}

// Ð’ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ ÐºÐ¾Ð¼Ð°Ð½Ð´ JSON:
if (command.find("sound") != command.end()) {
    std::string sound = command["sound"];
    if (sound == "notification") {
        buzzer_play_notification();
    } else if (sound == "error") {
        buzzer_play_error();
    }
}
```

### ðŸ“¡ ÐŸÑ€Ð¸Ð¼ÐµÑ€: Ð”Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Wi-Fi (Pico W)

#### ÐÑ€Ñ…Ð¸Ñ‚ÐµÐºÑ‚ÑƒÑ€Ð° Ð¼Ð¾Ð´ÑƒÐ»Ñ:
```
src/network/
â”œâ”€â”€ wifi_manager.cpp    # Ð£Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Wi-Fi Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸ÐµÐ¼
â”œâ”€â”€ web_server.cpp      # HTTP ÑÐµÑ€Ð²ÐµÑ€ Ð´Ð»Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´
â””â”€â”€ mqtt_client.cpp     # MQTT ÐºÐ»Ð¸ÐµÐ½Ñ‚ (Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾)

include/network/
â”œâ”€â”€ wifi_manager.h
â”œâ”€â”€ web_server.h
â””â”€â”€ mqtt_client.h
```

#### API Ð¸Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹Ñ:
```cpp
// include/network/wifi_manager.h
typedef enum {
    WIFI_DISCONNECTED,
    WIFI_CONNECTING,
    WIFI_CONNECTED,
    WIFI_ERROR
} wifi_status_t;

void wifi_init(const char* ssid, const char* password);
wifi_status_t wifi_get_status(void);
void wifi_update(void);  // ÐÐµÐ±Ð»Ð¾ÐºÐ¸Ñ€ÑƒÑŽÑ‰Ð°Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ° ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ñ
const char* wifi_get_ip(void);
```

### ðŸŽ® ÐŸÑ€Ð¸Ð¼ÐµÑ€: Ð”Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð´Ð¶Ð¾Ð¹ÑÑ‚Ð¸ÐºÐ°

#### ÐšÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ñ GPIO:
```cpp
// include/input/joystick.h
#define JOYSTICK_X_PIN    26  // ADC0
#define JOYSTICK_Y_PIN    27  // ADC1
#define JOYSTICK_BTN_PIN  16  // Digital

typedef struct {
    int16_t x;        // -1000 to +1000
    int16_t y;        // -1000 to +1000
    bool button;      // true = pressed
    bool changed;     // true = state changed
} joystick_state_t;
```

#### Ð˜Ð½Ñ‚ÐµÐ³Ñ€Ð°Ñ†Ð¸Ñ Ñ ÑÐ¼Ð¾Ñ†Ð¸ÑÐ¼Ð¸:
```cpp
// Ð’ main.cpp
joystick_state_t joystick = joystick_read();

if (joystick.changed) {
    if (joystick.x > 500) {
        current_emotion = "happy";
    } else if (joystick.x < -500) {
        current_emotion = "sad";
    } else if (joystick.y > 500) {
        current_emotion = "surprise";
    } else if (joystick.button) {
        current_emotion = "smile";
    }
}
```

### ðŸŒ¡ï¸ ÐŸÑ€Ð¸Ð¼ÐµÑ€: Ð”Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð´Ð°Ñ‚Ñ‡Ð¸ÐºÐ¾Ð²

#### ÐœÐ¾Ð´ÑƒÐ»ÑŒÐ½Ð°Ñ Ð°Ñ€Ñ…Ð¸Ñ‚ÐµÐºÑ‚ÑƒÑ€Ð°:
```cpp
// include/sensors/sensor_manager.h
typedef struct {
    float temperature;    // Â°C
    float humidity;       // %
    uint16_t light_level; // 0-1023
    bool motion_detected; // PIR sensor
    uint32_t timestamp;   // ms
} sensor_data_t;

// ÐÐµÐ±Ð»Ð¾ÐºÐ¸Ñ€ÑƒÑŽÑ‰Ð¸Ð¹ API
void sensors_init(void);
void sensors_update(void);          // Ð’Ñ‹Ð·Ñ‹Ð²Ð°ÐµÑ‚ÑÑ ÐºÐ°Ð¶Ð´Ñ‹Ð¹ Ñ†Ð¸ÐºÐ»
sensor_data_t sensors_get_data(void);
bool sensors_data_ready(void);      // ÐÐ¾Ð²Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹
```

#### Ð ÐµÐ°ÐºÑ†Ð¸Ñ Ð½Ð° Ð´Ð°Ñ‚Ñ‡Ð¸ÐºÐ¸:
```cpp
// ÐÐ²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¾Ðµ Ð¿ÐµÑ€ÐµÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ ÑÐ¼Ð¾Ñ†Ð¸Ð¹ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ð´Ð°Ñ‚Ñ‡Ð¸ÐºÐ¾Ð²
void update_emotion_from_sensors() {
    sensor_data_t sensors = sensors_get_data();
    
    if (sensors.motion_detected) {
        current_emotion = "surprise";
        emotion_timer = get_time();
    } else if (sensors.temperature > 30.0f) {
        current_emotion = "embarrassed";  // "Ð¶Ð°Ñ€ÐºÐ¾"
    } else if (sensors.light_level < 100) {
        current_emotion = "sleep";        // "Ñ‚ÐµÐ¼Ð½Ð¾"
    }
}
```

### ðŸ”§ Ð¨Ð°Ð±Ð»Ð¾Ð½ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ð¼Ð¾Ð´ÑƒÐ»Ñ

#### 1. Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ Ñ„Ð°Ð¹Ð»Ð¾Ð²ÑƒÑŽ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ñƒ:
```bash
mkdir src/new_module
mkdir include/new_module
touch src/new_module/new_module.cpp
touch include/new_module/new_module.h
```

#### 2. Ð‘Ð°Ð·Ð¾Ð²Ñ‹Ð¹ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ñ‡Ð½Ñ‹Ð¹ Ñ„Ð°Ð¹Ð»:
```cpp
#ifndef NEW_MODULE_H
#define NEW_MODULE_H

#include "pico/stdlib.h"

// ÐšÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ñ
#define MODULE_ENABLED 1

// Ð¡Ð¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ Ð¼Ð¾Ð´ÑƒÐ»Ñ
typedef struct {
    bool initialized;
    bool enabled;
    uint32_t last_update;
} module_state_t;

// API
void module_init(void);
void module_update(void);    // ÐÐµÐ±Ð»Ð¾ÐºÐ¸Ñ€ÑƒÑŽÑ‰Ð°Ñ
void module_enable(bool enable);
bool module_is_ready(void);

#endif
```

#### 3. Ð‘Ð°Ð·Ð¾Ð²Ð°Ñ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ:
```cpp
#include "new_module.h"

static module_state_t state = {0};

void module_init(void) {
    if (state.initialized) return;
    
    // Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ GPIO, Ð¿ÐµÑ€Ð¸Ñ„ÐµÑ€Ð¸Ð¸
    
    state.initialized = true;
    state.enabled = true;
    state.last_update = to_ms_since_boot(get_absolute_time());
    
    printf("[MODULE] Initialized\n");
}

void module_update(void) {
    if (!state.enabled || !state.initialized) return;
    
    uint32_t current_time = to_ms_since_boot(get_absolute_time());
    
    // ÐÐµÐ±Ð»Ð¾ÐºÐ¸Ñ€ÑƒÑŽÑ‰Ð°Ñ Ð»Ð¾Ð³Ð¸ÐºÐ° Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ
    
    state.last_update = current_time;
}
```

### ðŸ“ Ð§ÐµÐº-Ð»Ð¸ÑÑ‚ Ð¸Ð½Ñ‚ÐµÐ³Ñ€Ð°Ñ†Ð¸Ð¸

#### ÐŸÐµÑ€ÐµÐ´ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸ÐµÐ¼:
- âœ… ÐŸÑ€Ð¾Ð²ÐµÑ€Ð¸Ñ‚ÑŒ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾ÑÑ‚ÑŒ GPIO Ð¿Ð¸Ð½Ð¾Ð²
- âœ… ÐžÑ†ÐµÐ½Ð¸Ñ‚ÑŒ Ð¿Ð¾Ñ‚Ñ€ÐµÐ±Ð»ÐµÐ½Ð¸Ðµ Ð¿Ð°Ð¼ÑÑ‚Ð¸
- âœ… Ð£Ð±ÐµÐ´Ð¸Ñ‚ÑŒÑÑ Ð² ÑÐ¾Ð²Ð¼ÐµÑÑ‚Ð¸Ð¼Ð¾ÑÑ‚Ð¸ Ñ 1ms Ñ†Ð¸ÐºÐ»Ð¾Ð¼
- âœ… Ð¡Ð¿Ð»Ð°Ð½Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ ÐºÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ð¾Ð½Ð½Ñ‹Ðµ Ð¾Ð¿Ñ†Ð¸Ð¸

#### ÐŸÐ¾ÑÐ»Ðµ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ:
- âœ… ÐŸÑ€Ð¾Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð½Ð° Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾Ð¼ Ð¾Ð±Ð¾Ñ€ÑƒÐ´Ð¾Ð²Ð°Ð½Ð¸Ð¸
- âœ… ÐŸÑ€Ð¾Ð²ÐµÑ€Ð¸Ñ‚ÑŒ Ð²Ð»Ð¸ÑÐ½Ð¸Ðµ Ð½Ð° Ð¿Ñ€Ð¾Ð¸Ð·Ð²Ð¾Ð´Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ Ð°Ð½Ð¸Ð¼Ð°Ñ†Ð¸Ð¹
- âœ… ÐžÐ±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ CMakeLists.txt
- âœ… Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ð°Ñ†Ð¸ÑŽ Ð² README.md
- âœ… Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¸Ð¼ÐµÑ€Ñ‹ ÐºÐ¾Ð¼Ð°Ð½Ð´ JSON

#### Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð² CMakeLists.txt:
```cmake
# ÐÐ¾Ð²Ñ‹Ð¹ Ð¼Ð¾Ð´ÑƒÐ»ÑŒ
target_include_directories(robot_pico PRIVATE
    ${CMAKE_CURRENT_LIST_DIR}/include/new_module
)

# Ð”Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÐ¸ (ÐµÑÐ»Ð¸ Ð½ÑƒÐ¶Ð½Ð¾)
target_link_libraries(robot_pico
    hardware_adc      # Ð”Ð»Ñ Ð°Ð½Ð°Ð»Ð¾Ð³Ð¾Ð²Ñ‹Ñ… Ð´Ð°Ñ‚Ñ‡Ð¸ÐºÐ¾Ð²
    hardware_pwm      # Ð”Ð»Ñ buzzer/servo
    hardware_i2c      # Ð”Ð»Ñ I2C Ð´Ð°Ñ‚Ñ‡Ð¸ÐºÐ¾Ð²
)
```

### ðŸŽ¯ ÐŸÑ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚Ñ‹ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹

#### Ð’Ñ‹ÑÐ¾ÐºÐ¸Ð¹ Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚ (Ð»ÐµÐ³ÐºÐ¾ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð¾Ð²Ð°Ñ‚ÑŒ):
1. **Buzzer** - Ð·Ð²ÑƒÐºÐ¾Ð²Ñ‹Ðµ ÑÑ„Ñ„ÐµÐºÑ‚Ñ‹
2. **LED Ð¸Ð½Ð´Ð¸ÐºÐ°Ñ‚Ð¾Ñ€Ñ‹** - ÑÑ‚Ð°Ñ‚ÑƒÑÐ½Ñ‹Ðµ ÑÐ²ÐµÑ‚Ð¾Ð´Ð¸Ð¾Ð´Ñ‹
3. **ÐšÐ½Ð¾Ð¿ÐºÐ¸** - Ñ„Ð¸Ð·Ð¸Ñ‡ÐµÑÐºÐ¾Ðµ ÑƒÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ
4. **ÐŸÐ¾Ñ‚ÐµÐ½Ñ†Ð¸Ð¾Ð¼ÐµÑ‚Ñ€Ñ‹** - Ð°Ð½Ð°Ð»Ð¾Ð³Ð¾Ð²Ñ‹Ðµ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸

#### Ð¡Ñ€ÐµÐ´Ð½Ð¸Ð¹ Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚ (Ñ‚Ñ€ÐµÐ±ÑƒÐµÑ‚ Ð¿Ð»Ð°Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ):
1. **Ð”Ð°Ñ‚Ñ‡Ð¸ÐºÐ¸ Ñ‚ÐµÐ¼Ð¿ÐµÑ€Ð°Ñ‚ÑƒÑ€Ñ‹/Ð²Ð»Ð°Ð¶Ð½Ð¾ÑÑ‚Ð¸** (DHT22, SHT30)
2. **Ð”Ð°Ñ‚Ñ‡Ð¸Ðº Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ñ** (PIR)
3. **Ð¤Ð¾Ñ‚Ð¾Ð´Ð°Ñ‚Ñ‡Ð¸Ðº** - Ñ€ÐµÐ°ÐºÑ†Ð¸Ñ Ð½Ð° Ð¾ÑÐ²ÐµÑ‰ÐµÐ½Ð¸Ðµ
4. **Ð¡ÐµÑ€Ð²Ð¾ Ð¼Ð¾Ñ‚Ð¾Ñ€Ñ‹** - Ñ„Ð¸Ð·Ð¸Ñ‡ÐµÑÐºÐ¸Ðµ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ñ

#### ÐÐ¸Ð·ÐºÐ¸Ð¹ Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚ (ÑÐ»Ð¾Ð¶Ð½Ð°Ñ Ð¸Ð½Ñ‚ÐµÐ³Ñ€Ð°Ñ†Ð¸Ñ):
1. **Wi-Fi/Bluetooth** - Ð±ÐµÑÐ¿Ñ€Ð¾Ð²Ð¾Ð´Ð½Ð°Ñ ÑÐ²ÑÐ·ÑŒ
2. **SD ÐºÐ°Ñ€Ñ‚Ð°** - Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ…
3. **ÐšÐ°Ð¼ÐµÑ€Ð°** - ÐºÐ¾Ð¼Ð¿ÑŒÑŽÑ‚ÐµÑ€Ð½Ð¾Ðµ Ð·Ñ€ÐµÐ½Ð¸Ðµ
4. **Ð“Ð¾Ð»Ð¾ÑÐ¾Ð²Ð¾Ð¹ ÑÐ¸Ð½Ñ‚ÐµÐ·** - TTS

---

**ÐŸÑ€Ð¸Ð½Ñ†Ð¸Ð¿:** ÐÐ°Ñ‡Ð¸Ð½Ð°Ð¹ Ñ Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ð³Ð¾, Ñ‚ÐµÑÑ‚Ð¸Ñ€ÑƒÐ¹ Ð½Ð° ÐºÐ°Ð¶Ð´Ð¾Ð¼ ÑˆÐ°Ð³Ðµ, ÑÐ¾Ñ…Ñ€Ð°Ð½ÑÐ¹ Ð¿Ñ€Ð¾Ð¸Ð·Ð²Ð¾Ð´Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ!